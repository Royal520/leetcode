**æ–¹æ³•ä¸€ï¼šæ’åº + äºŒåˆ†æŸ¥æ‰¾**

æˆ‘ä»¬å¯ä»¥å¯¹è¯æ°´æ•°ç»„è¿›è¡Œæ’åºï¼Œç„¶åéå†å’’è¯­æ•°ç»„ï¼Œå¯¹äºæ¯ä¸ªå’’è¯­ $v$ï¼Œåˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äº $\frac{success}{v}$ çš„è¯æ°´ï¼Œä¸‹æ ‡è®°ä¸º $i$ï¼Œé‚£ä¹ˆè¯æ°´çš„é•¿åº¦å‡å» $i$ å³ä¸ºèƒ½è·Ÿè¯¥å’’è¯­æˆåŠŸç»„åˆçš„è¯æ°´æ•°ç›®ã€‚

* [sol1-Python3]

```python
class Solution:
    def successfulPairs(
        self, spells: List[int], potions: List[int], success: int
    ) -> List[int]:
        potions.sort()
        m = len(potions)
        return [m - bisect_left(potions, success / v) for v in spells]
```

* [sol1-Java]

```java
class Solution {
    public int[] successfulPairs(int[] spells, int[] potions, long success) {
        Arrays.sort(potions);
        int n = spells.length, m = potions.length;
        int[] ans = new int[n];
        for (int i = 0; i < n; ++i) {
            int left = 0, right = m;
            while (left < right) {
                int mid = (left + right) >> 1;
                if ((long) spells[i] * potions[mid] >= success) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            ans[i] = m - left;
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {
        sort(potions.begin(), potions.end());
        vector<int> ans;
        int m = potions.size();
        for (int& v : spells) {
            int i = lower_bound(potions.begin(), potions.end(), success * 1.0 / v) - potions.begin();
            ans.push_back(m - i);
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func successfulPairs(spells []int, potions []int, success int64) (ans []int) {
	sort.Ints(potions)
	m := len(potions)
	for _, v := range spells {
		i := sort.Search(m, func(i int) bool { return int64(potions[i]*v) >= success })
		ans = append(ans, m-i)
	}
	return ans
}
```

* [sol1-TypeScript]

```ts
function successfulPairs(spells: number[], potions: number[], success: number): number[] {
    potions.sort((a, b) => a - b);
    const m = potions.length;
    const ans: number[] = [];
    for (const v of spells) {
        let left = 0;
        let right = m;
        while (left < right) {
            const mid = (left + right) >> 1;
            if (v * potions[mid] >= success) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        ans.push(m - left);
    }
    return ans;
}
```

æ—¶é—´å¤æ‚åº¦ $O((m + n) \times \log m)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(\log n)$ã€‚å…¶ä¸­ $m$ å’Œ $n$ åˆ†åˆ«ä¸ºè¯æ°´æ•°ç»„å’Œå’’è¯­æ•°ç»„çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
