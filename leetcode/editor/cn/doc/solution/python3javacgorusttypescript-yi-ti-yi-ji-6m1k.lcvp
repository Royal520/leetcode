**æ–¹æ³•ä¸€ï¼šå“ˆå¸Œè¡¨**

æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå“ˆå¸Œè¡¨ $cnt$ï¼Œç”¨äºŽå­˜å‚¨æ‰€æœ‰é•¿åº¦ä¸º $10$ çš„å­å­—ç¬¦ä¸²å‡ºçŽ°çš„æ¬¡æ•°ã€‚

éåŽ†å­—ç¬¦ä¸² $s$ çš„æ‰€æœ‰é•¿åº¦ä¸º $10$ çš„å­å­—ç¬¦ä¸²ï¼Œå¯¹äºŽå½“å‰å­å­—ç¬¦ä¸² $t$ï¼Œæˆ‘ä»¬æ›´æ–°å…¶åœ¨å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„è®¡æ•°ã€‚å¦‚æžœ $t$ çš„è®¡æ•°ä¸º $2$ï¼Œæˆ‘ä»¬å°±å°†å®ƒåŠ å…¥ç­”æ¡ˆã€‚

éåŽ†ç»“æŸåŽï¼Œè¿”å›žç­”æ¡ˆæ•°ç»„å³å¯ã€‚

* [sol1-Python3]

```python
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        cnt = Counter()
        ans = []
        for i in range(len(s) - 10 + 1):
            t = s[i : i + 10]
            cnt[t] += 1
            if cnt[t] == 2:
                ans.append(t)
        return ans
```

* [sol1-Java]

```java
class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        Map<String, Integer> cnt = new HashMap<>();
        List<String> ans = new ArrayList<>();
        for (int i = 0; i < s.length() - 10 + 1; ++i) {
            String t = s.substring(i, i + 10);
            if (cnt.merge(t, 1, Integer::sum) == 2) {
                ans.add(t);
            }
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        unordered_map<string, int> cnt;
        vector<string> ans;
        for (int i = 0, n = s.size() - 10 + 1; i < n; ++i) {
            auto t = s.substr(i, 10);
            if (++cnt[t] == 2) {
                ans.emplace_back(t);
            }
        }
        return ans;
    }
};
```

* [sol1-Go]

```go
func findRepeatedDnaSequences(s string) (ans []string) {
	cnt := map[string]int{}
	for i := 0; i < len(s)-10+1; i++ {
		t := s[i : i+10]
		cnt[t]++
		if cnt[t] == 2 {
			ans = append(ans, t)
		}
	}
	return
}
```

* [sol1-Rust]

```rust
use std::collections::HashMap;

impl Solution {
    pub fn find_repeated_dna_sequences(s: String) -> Vec<String> {
        if s.len() < 10 {
            return vec![]
        }
        let mut cnt = HashMap::new();
        let mut ans = Vec::new();
        for i in 0..s.len() - 9 {
            let t = &s[i..i + 10];
            let count = cnt.entry(t).or_insert(0);
            *count += 1;
            if *count == 2 {
                ans.push(t.to_string());
            }
        }
        ans
    }
}
```

* [sol1-TypeScript]

```ts
function findRepeatedDnaSequences(s: string): string[] {
    const n = s.length;
    const cnt: Map<string, number> = new Map();
    const ans: string[] = [];
    for (let i = 0; i <= n - 10; ++i) {
        const t = s.slice(i, i + 10);
        cnt.set(t, (cnt.get(t) ?? 0) + 1);
        if (cnt.get(t) === 2) {
            ans.push(t);
        }
    }
    return ans;
}
```

* [sol1-C#]

```cs
public class Solution {
    public IList<string> FindRepeatedDnaSequences(string s) {
        var cnt = new Dictionary<string, int>();
        var ans = new List<string>();
        for (int i = 0; i < s.Length - 10 + 1; ++i) {
            var t = s.Substring(i, 10);
            if (!cnt.ContainsKey(t)) {
                cnt[t] = 0;
            }
            if (++cnt[t] == 2) {
                ans.Add(t);
            }
        }
        return ans;
    }
}
```

æ—¶é—´å¤æ‚åº¦ $O(n \times 10)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n \times 10)$ã€‚å…¶ä¸­ $n$ æ˜¯å­—ç¬¦ä¸² $s$ çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~
